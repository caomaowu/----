针对“卡顿”和“闪退”的问题，通常是由于在 UI 主线程中一次性加载并渲染了过多数据，或者进行了耗时的 I/O 操作。

### 核心原因分析
1.  **UI 渲染阻塞**: 如果一个项目关联了几十甚至上百条探伤记录，系统在打开项目详情页时会尝试一次性创建所有记录的卡片 (`TimelineNode`)。这会产生大量的布局计算和对象创建，导致界面卡死（无响应），严重时会被操作系统判定为“未响应”甚至崩溃。
2.  **数据库 I/O 阻塞**: 虽然读取数据库通常很快，但在数据量大或数据库繁忙（如后台正在扫描）时，在主线程直接查询也会导致卡顿。

### 优化方案

#### 1. 实施分页加载 (Pagination / Lazy Loading)
**原理**: 每次只加载和渲染最近的 **20 条** 记录。
**效果**: 极大地减少进入页面时的初始化时间。用户滚动到底部时，再自动加载下一页或点击“加载更多”。这是解决卡顿最立竿见影的方法。

#### 2. 异步数据读取 (Asynchronous Loading)
**原理**: 将 `get_project_inspections` 数据库查询操作移至后台线程执行。
**效果**: 确保即使数据库查询变慢，UI 界面依然保持流畅响应，不会出现“转圈”或卡死。

#### 3. 渲染性能优化
**原理**: 简化 `TimelineNode` 的层级结构，或者在数据量极大时（如 >500条）考虑从 `ScrollArea` 切换为 `QListView`（虚拟列表技术）。
**建议**: 目前先采用方案 1 和 2，通常足以解决数百条记录的性能问题。

### 实施计划
1.  修改 `InspectionTimeline` 类，增加分页逻辑（`limit`, `offset`）。
2.  引入 `QThread` 或 `Worker` 将数据库查询异步化。
3.  在列表底部添加一个“加载更多”按钮或加载指示器。

**您是否同意先实施“分页加载”和“异步读取”这两个优化方案？**